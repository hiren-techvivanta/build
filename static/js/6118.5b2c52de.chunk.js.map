{"version":3,"file":"static/js/6118.5b2c52de.chunk.js","mappings":"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","sources":["../node_modules/@wagmi/connectors/src/coinbaseWallet.ts"],"sourcesContent":["import type {\n  Preference,\n  ProviderInterface,\n  createCoinbaseWalletSDK,\n} from '@coinbase/wallet-sdk'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport type { Compute, Mutable, Omit } from '@wagmi/core/internal'\nimport type {\n  CoinbaseWalletProvider as CBW_Provider,\n  CoinbaseWalletSDK as CBW_SDK,\n} from 'cbw-sdk'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  type Hex,\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\ntype Version = '3' | '4'\n\nexport type CoinbaseWalletParameters<version extends Version = '3'> =\n  version extends '4'\n    ? Compute<\n        {\n          headlessMode?: false | undefined\n          /** Coinbase Wallet SDK version */\n          version?: version | '3' | undefined\n        } & Version4Parameters\n      >\n    : Compute<\n        {\n          /**\n           * @deprecated `headlessMode` will be removed in the next major version. Upgrade to `version: '4'`.\n           */\n          headlessMode?: true | undefined\n          /**\n           * Coinbase Wallet SDK version\n           * @deprecated Version 3 will be removed in the next major version. Upgrade to `version: '4'`.\n           * @default '4'\n           */\n          version?: version | '4' | undefined\n        } & Version3Parameters\n      >\n\ncoinbaseWallet.type = 'coinbaseWallet' as const\nexport function coinbaseWallet<version extends Version>(\n  parameters: CoinbaseWalletParameters<version> = {} as any,\n): version extends '4'\n  ? ReturnType<typeof version4>\n  : ReturnType<typeof version3> {\n  if (parameters.version === '3' || parameters.headlessMode)\n    return version3(parameters as Version3Parameters) as any\n  return version4(parameters as Version4Parameters) as any\n}\n\ntype Version4Parameters = Mutable<\n  Omit<\n    Parameters<typeof createCoinbaseWalletSDK>[0],\n    | 'appChainIds' // set via wagmi config\n    | 'preference'\n  > & {\n    // TODO(v3): Remove `Preference['options']`\n    /**\n     * Preference for the type of wallet to display.\n     * @default 'all'\n     */\n    preference?: Preference['options'] | Compute<Preference> | undefined\n  }\n>\n\nfunction version4(parameters: Version4Parameters) {\n  type Provider = ProviderInterface & {\n    // for backwards compatibility\n    close?(): void\n  }\n  type Properties = {\n    connect(parameters?: {\n      chainId?: number | undefined\n      instantOnboarding?: boolean | undefined\n      isReconnecting?: boolean | undefined\n    }): Promise<{\n      accounts: readonly Address[]\n      chainId: number\n    }>\n  }\n\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n            params:\n              'instantOnboarding' in rest && rest.instantOnboarding\n                ? [{ onboarding: 'instant' }]\n                : [],\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close?.()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        (await provider.request({\n          method: 'eth_accounts',\n        })) as string[]\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = (await provider.request({\n        method: 'eth_chainId',\n      })) as Hex\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        const preference = (() => {\n          if (typeof parameters.preference === 'string')\n            return { options: parameters.preference }\n          return {\n            ...parameters.preference,\n            options: parameters.preference?.options ?? 'all',\n          }\n        })()\n\n        const { createCoinbaseWalletSDK } = await import('@coinbase/wallet-sdk')\n        const sdk = createCoinbaseWalletSDK({\n          ...parameters,\n          appChainIds: config.chains.map((x) => x.id),\n          preference,\n        })\n\n        walletProvider = sdk.getProvider()\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n\ntype Version3Parameters = Mutable<\n  Omit<\n    ConstructorParameters<typeof CBW_SDK>[0],\n    'reloadOnDisconnect' // remove property since TSDoc says default is `true`\n  >\n> & {\n  /**\n   * Fallback Ethereum JSON RPC URL\n   * @default \"\"\n   */\n  jsonRpcUrl?: string | undefined\n  /**\n   * Fallback Ethereum Chain ID\n   * @default 1\n   */\n  chainId?: number | undefined\n  /**\n   * Whether or not to reload dapp automatically after disconnect.\n   * @default false\n   */\n  reloadOnDisconnect?: boolean | undefined\n}\n\nfunction version3(parameters: Version3Parameters) {\n  const reloadOnDisconnect = false\n\n  type Provider = CBW_Provider\n\n  let sdk: CBW_SDK | undefined\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        await provider.request<string[]>({\n          method: 'eth_accounts',\n        })\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = await provider.request<Hex>({\n        method: 'eth_chainId',\n      })\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const CoinbaseWalletSDK = await (async () => {\n          const { default: SDK } = await import('cbw-sdk')\n          if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n            return SDK.default\n          return SDK as unknown as typeof SDK.default\n        })()\n\n        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect })\n\n        // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.\n        const walletExtensionChainId = (\n          sdk as unknown as {\n            get walletExtension(): { getChainId(): number } | undefined\n          }\n        ).walletExtension?.getChainId()\n\n        const chain =\n          config.chains.find((chain) =>\n            parameters.chainId\n              ? chain.id === parameters.chainId\n              : chain.id === walletExtensionChainId,\n          ) || config.chains[0]\n        const chainId = parameters.chainId || chain?.id\n        const jsonRpcUrl =\n          parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0]\n\n        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId)\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n"],"names":["coinbaseWallet","parameters","arguments","length","undefined","version","headlessMode","reloadOnDisconnect","sdk","walletProvider","accountsChanged","chainChanged","disconnect","createConnector","config","id","name","rdns","type","connect","chainId","provider","this","getProvider","accounts","request","method","map","x","getAddress","onAccountsChanged","bind","on","onChainChanged","onDisconnect","currentChainId","getChainId","chain","switchChain","catch","error","code","UserRejectedRequestError","test","message","removeListener","close","getAccounts","Number","CoinbaseWalletSDK","default","SDK","walletExtensionChainId","walletExtension","chains","find","jsonRpcUrl","rpcUrls","http","makeWeb3Provider","isAuthorized","_ref2","addEthereumChainParameter","SwitchChainError","ChainNotConfiguredError","params","numberToHex","blockExplorerUrls","blockExplorers","url","addEthereumChain","chainName","iconUrls","nativeCurrency","emitter","emit","_error","version3","rest","instantOnboarding","onboarding","preference","options","createCoinbaseWalletSDK","appChainIds","_ref","version4"],"sourceRoot":""}